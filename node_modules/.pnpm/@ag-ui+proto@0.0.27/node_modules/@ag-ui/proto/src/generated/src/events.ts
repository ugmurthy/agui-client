// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: src/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct, Value } from "../google/protobuf/struct";

export const protobufPackage = "agentwire";

export enum EventType {
  TEXT_MESSAGE_START = 0,
  TEXT_MESSAGE_CONTENT = 1,
  TEXT_MESSAGE_END = 2,
  TOOL_CALL_START = 3,
  TOOL_CALL_ARGS = 4,
  TOOL_CALL_END = 5,
  STATE_SNAPSHOT = 6,
  STATE_DELTA = 7,
  MESSAGES_SNAPSHOT = 8,
  RAW_EVENT = 9,
  CUSTOM_EVENT = 10,
  RUN_STARTED = 11,
  RUN_FINISHED = 12,
  RUN_ERROR = 13,
  STEP_STARTED = 14,
  STEP_FINISHED = 15,
  UNRECOGNIZED = -1,
}

export interface BaseEvent {
  type: EventType;
  timestamp?: number | undefined;
  threadId?: string | undefined;
  runId?: string | undefined;
  rawEvent?: any | undefined;
}

export interface TextMessageStart {
  baseEvent: BaseEvent | undefined;
  messageId: string;
  role?: string | undefined;
}

export interface TextMessageContent {
  baseEvent: BaseEvent | undefined;
  messageId: string;
  delta: string;
}

export interface TextMessageEnd {
  baseEvent: BaseEvent | undefined;
  messageId: string;
}

export interface ToolCallStart {
  baseEvent: BaseEvent | undefined;
  toolCallId: string;
  toolCallName: string;
  parentMessageId?: string | undefined;
}

export interface ToolCallArgs {
  baseEvent: BaseEvent | undefined;
  toolCallId: string;
  delta: string;
}

export interface ToolCallEnd {
  baseEvent: BaseEvent | undefined;
  toolCallId: string;
}

export interface StateSnapshot {
  baseEvent: BaseEvent | undefined;
  snapshot: any | undefined;
}

export interface StateDelta {
  baseEvent: BaseEvent | undefined;
  delta: any | undefined;
}

export interface MessagesSnapshot {
  baseEvent: BaseEvent | undefined;
  messages: { [key: string]: any }[];
}

export interface RawEvent {
  baseEvent: BaseEvent | undefined;
  event: any | undefined;
  source?: string | undefined;
}

export interface CustomEvent {
  baseEvent: BaseEvent | undefined;
  name: string;
  value?: any | undefined;
}

export interface RunStarted {
  baseEvent: BaseEvent | undefined;
}

export interface RunFinished {
  baseEvent: BaseEvent | undefined;
}

export interface RunError {
  baseEvent: BaseEvent | undefined;
  code?: string | undefined;
  message: string;
}

export interface StepStarted {
  baseEvent: BaseEvent | undefined;
  stepName: string;
}

export interface StepFinished {
  baseEvent: BaseEvent | undefined;
  stepName: string;
}

export interface Event {
  textMessageStart?: TextMessageStart | undefined;
  textMessageContent?: TextMessageContent | undefined;
  textMessageEnd?: TextMessageEnd | undefined;
  toolCallStart?: ToolCallStart | undefined;
  toolCallArgs?: ToolCallArgs | undefined;
  toolCallEnd?: ToolCallEnd | undefined;
  stateSnapshot?: StateSnapshot | undefined;
  stateDelta?: StateDelta | undefined;
  messagesSnapshot?: MessagesSnapshot | undefined;
  rawEvent?: RawEvent | undefined;
  customEvent?: CustomEvent | undefined;
  runStarted?: RunStarted | undefined;
  runFinished?: RunFinished | undefined;
  runError?: RunError | undefined;
  stepStarted?: StepStarted | undefined;
  stepFinished?: StepFinished | undefined;
}

function createBaseBaseEvent(): BaseEvent {
  return { type: 0, timestamp: undefined, threadId: undefined, runId: undefined, rawEvent: undefined };
}

export const BaseEvent: MessageFns<BaseEvent> = {
  encode(message: BaseEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.timestamp !== undefined) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.threadId !== undefined) {
      writer.uint32(26).string(message.threadId);
    }
    if (message.runId !== undefined) {
      writer.uint32(34).string(message.runId);
    }
    if (message.rawEvent !== undefined) {
      Value.encode(Value.wrap(message.rawEvent), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.threadId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rawEvent = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BaseEvent>, I>>(base?: I): BaseEvent {
    return BaseEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaseEvent>, I>>(object: I): BaseEvent {
    const message = createBaseBaseEvent();
    message.type = object.type ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.threadId = object.threadId ?? undefined;
    message.runId = object.runId ?? undefined;
    message.rawEvent = object.rawEvent ?? undefined;
    return message;
  },
};

function createBaseTextMessageStart(): TextMessageStart {
  return { baseEvent: undefined, messageId: "", role: undefined };
}

export const TextMessageStart: MessageFns<TextMessageStart> = {
  encode(message: TextMessageStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.role !== undefined) {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMessageStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TextMessageStart>, I>>(base?: I): TextMessageStart {
    return TextMessageStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextMessageStart>, I>>(object: I): TextMessageStart {
    const message = createBaseTextMessageStart();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messageId = object.messageId ?? "";
    message.role = object.role ?? undefined;
    return message;
  },
};

function createBaseTextMessageContent(): TextMessageContent {
  return { baseEvent: undefined, messageId: "", delta: "" };
}

export const TextMessageContent: MessageFns<TextMessageContent> = {
  encode(message: TextMessageContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.delta !== "") {
      writer.uint32(26).string(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMessageContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TextMessageContent>, I>>(base?: I): TextMessageContent {
    return TextMessageContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextMessageContent>, I>>(object: I): TextMessageContent {
    const message = createBaseTextMessageContent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messageId = object.messageId ?? "";
    message.delta = object.delta ?? "";
    return message;
  },
};

function createBaseTextMessageEnd(): TextMessageEnd {
  return { baseEvent: undefined, messageId: "" };
}

export const TextMessageEnd: MessageFns<TextMessageEnd> = {
  encode(message: TextMessageEnd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageEnd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMessageEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TextMessageEnd>, I>>(base?: I): TextMessageEnd {
    return TextMessageEnd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextMessageEnd>, I>>(object: I): TextMessageEnd {
    const message = createBaseTextMessageEnd();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messageId = object.messageId ?? "";
    return message;
  },
};

function createBaseToolCallStart(): ToolCallStart {
  return { baseEvent: undefined, toolCallId: "", toolCallName: "", parentMessageId: undefined };
}

export const ToolCallStart: MessageFns<ToolCallStart> = {
  encode(message: ToolCallStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.toolCallName !== "") {
      writer.uint32(26).string(message.toolCallName);
    }
    if (message.parentMessageId !== undefined) {
      writer.uint32(34).string(message.parentMessageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolCallName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentMessageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToolCallStart>, I>>(base?: I): ToolCallStart {
    return ToolCallStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallStart>, I>>(object: I): ToolCallStart {
    const message = createBaseToolCallStart();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.toolCallId = object.toolCallId ?? "";
    message.toolCallName = object.toolCallName ?? "";
    message.parentMessageId = object.parentMessageId ?? undefined;
    return message;
  },
};

function createBaseToolCallArgs(): ToolCallArgs {
  return { baseEvent: undefined, toolCallId: "", delta: "" };
}

export const ToolCallArgs: MessageFns<ToolCallArgs> = {
  encode(message: ToolCallArgs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.delta !== "") {
      writer.uint32(26).string(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallArgs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToolCallArgs>, I>>(base?: I): ToolCallArgs {
    return ToolCallArgs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallArgs>, I>>(object: I): ToolCallArgs {
    const message = createBaseToolCallArgs();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.toolCallId = object.toolCallId ?? "";
    message.delta = object.delta ?? "";
    return message;
  },
};

function createBaseToolCallEnd(): ToolCallEnd {
  return { baseEvent: undefined, toolCallId: "" };
}

export const ToolCallEnd: MessageFns<ToolCallEnd> = {
  encode(message: ToolCallEnd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallEnd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToolCallEnd>, I>>(base?: I): ToolCallEnd {
    return ToolCallEnd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallEnd>, I>>(object: I): ToolCallEnd {
    const message = createBaseToolCallEnd();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.toolCallId = object.toolCallId ?? "";
    return message;
  },
};

function createBaseStateSnapshot(): StateSnapshot {
  return { baseEvent: undefined, snapshot: undefined };
}

export const StateSnapshot: MessageFns<StateSnapshot> = {
  encode(message: StateSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.snapshot !== undefined) {
      Value.encode(Value.wrap(message.snapshot), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snapshot = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StateSnapshot>, I>>(base?: I): StateSnapshot {
    return StateSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateSnapshot>, I>>(object: I): StateSnapshot {
    const message = createBaseStateSnapshot();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.snapshot = object.snapshot ?? undefined;
    return message;
  },
};

function createBaseStateDelta(): StateDelta {
  return { baseEvent: undefined, delta: undefined };
}

export const StateDelta: MessageFns<StateDelta> = {
  encode(message: StateDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.delta !== undefined) {
      Value.encode(Value.wrap(message.delta), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delta = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StateDelta>, I>>(base?: I): StateDelta {
    return StateDelta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateDelta>, I>>(object: I): StateDelta {
    const message = createBaseStateDelta();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.delta = object.delta ?? undefined;
    return message;
  },
};

function createBaseMessagesSnapshot(): MessagesSnapshot {
  return { baseEvent: undefined, messages: [] };
}

export const MessagesSnapshot: MessageFns<MessagesSnapshot> = {
  encode(message: MessagesSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    for (const v of message.messages) {
      Struct.encode(Struct.wrap(v!), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessagesSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessagesSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(Struct.unwrap(Struct.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MessagesSnapshot>, I>>(base?: I): MessagesSnapshot {
    return MessagesSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessagesSnapshot>, I>>(object: I): MessagesSnapshot {
    const message = createBaseMessagesSnapshot();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  },
};

function createBaseRawEvent(): RawEvent {
  return { baseEvent: undefined, event: undefined, source: undefined };
}

export const RawEvent: MessageFns<RawEvent> = {
  encode(message: RawEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.event !== undefined) {
      Value.encode(Value.wrap(message.event), writer.uint32(18).fork()).join();
    }
    if (message.source !== undefined) {
      writer.uint32(26).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RawEvent>, I>>(base?: I): RawEvent {
    return RawEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RawEvent>, I>>(object: I): RawEvent {
    const message = createBaseRawEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.event = object.event ?? undefined;
    message.source = object.source ?? undefined;
    return message;
  },
};

function createBaseCustomEvent(): CustomEvent {
  return { baseEvent: undefined, name: "", value: undefined };
}

export const CustomEvent: MessageFns<CustomEvent> = {
  encode(message: CustomEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CustomEvent>, I>>(base?: I): CustomEvent {
    return CustomEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomEvent>, I>>(object: I): CustomEvent {
    const message = createBaseCustomEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.name = object.name ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseRunStarted(): RunStarted {
  return { baseEvent: undefined };
}

export const RunStarted: MessageFns<RunStarted> = {
  encode(message: RunStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RunStarted>, I>>(base?: I): RunStarted {
    return RunStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunStarted>, I>>(object: I): RunStarted {
    const message = createBaseRunStarted();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    return message;
  },
};

function createBaseRunFinished(): RunFinished {
  return { baseEvent: undefined };
}

export const RunFinished: MessageFns<RunFinished> = {
  encode(message: RunFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RunFinished>, I>>(base?: I): RunFinished {
    return RunFinished.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunFinished>, I>>(object: I): RunFinished {
    const message = createBaseRunFinished();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    return message;
  },
};

function createBaseRunError(): RunError {
  return { baseEvent: undefined, code: undefined, message: "" };
}

export const RunError: MessageFns<RunError> = {
  encode(message: RunError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.code !== undefined) {
      writer.uint32(18).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RunError>, I>>(base?: I): RunError {
    return RunError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunError>, I>>(object: I): RunError {
    const message = createBaseRunError();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.code = object.code ?? undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseStepStarted(): StepStarted {
  return { baseEvent: undefined, stepName: "" };
}

export const StepStarted: MessageFns<StepStarted> = {
  encode(message: StepStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.stepName !== "") {
      writer.uint32(18).string(message.stepName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stepName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StepStarted>, I>>(base?: I): StepStarted {
    return StepStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepStarted>, I>>(object: I): StepStarted {
    const message = createBaseStepStarted();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.stepName = object.stepName ?? "";
    return message;
  },
};

function createBaseStepFinished(): StepFinished {
  return { baseEvent: undefined, stepName: "" };
}

export const StepFinished: MessageFns<StepFinished> = {
  encode(message: StepFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.stepName !== "") {
      writer.uint32(18).string(message.stepName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stepName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StepFinished>, I>>(base?: I): StepFinished {
    return StepFinished.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepFinished>, I>>(object: I): StepFinished {
    const message = createBaseStepFinished();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.stepName = object.stepName ?? "";
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    textMessageStart: undefined,
    textMessageContent: undefined,
    textMessageEnd: undefined,
    toolCallStart: undefined,
    toolCallArgs: undefined,
    toolCallEnd: undefined,
    stateSnapshot: undefined,
    stateDelta: undefined,
    messagesSnapshot: undefined,
    rawEvent: undefined,
    customEvent: undefined,
    runStarted: undefined,
    runFinished: undefined,
    runError: undefined,
    stepStarted: undefined,
    stepFinished: undefined,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textMessageStart !== undefined) {
      TextMessageStart.encode(message.textMessageStart, writer.uint32(10).fork()).join();
    }
    if (message.textMessageContent !== undefined) {
      TextMessageContent.encode(message.textMessageContent, writer.uint32(18).fork()).join();
    }
    if (message.textMessageEnd !== undefined) {
      TextMessageEnd.encode(message.textMessageEnd, writer.uint32(26).fork()).join();
    }
    if (message.toolCallStart !== undefined) {
      ToolCallStart.encode(message.toolCallStart, writer.uint32(34).fork()).join();
    }
    if (message.toolCallArgs !== undefined) {
      ToolCallArgs.encode(message.toolCallArgs, writer.uint32(42).fork()).join();
    }
    if (message.toolCallEnd !== undefined) {
      ToolCallEnd.encode(message.toolCallEnd, writer.uint32(50).fork()).join();
    }
    if (message.stateSnapshot !== undefined) {
      StateSnapshot.encode(message.stateSnapshot, writer.uint32(58).fork()).join();
    }
    if (message.stateDelta !== undefined) {
      StateDelta.encode(message.stateDelta, writer.uint32(66).fork()).join();
    }
    if (message.messagesSnapshot !== undefined) {
      MessagesSnapshot.encode(message.messagesSnapshot, writer.uint32(74).fork()).join();
    }
    if (message.rawEvent !== undefined) {
      RawEvent.encode(message.rawEvent, writer.uint32(82).fork()).join();
    }
    if (message.customEvent !== undefined) {
      CustomEvent.encode(message.customEvent, writer.uint32(90).fork()).join();
    }
    if (message.runStarted !== undefined) {
      RunStarted.encode(message.runStarted, writer.uint32(98).fork()).join();
    }
    if (message.runFinished !== undefined) {
      RunFinished.encode(message.runFinished, writer.uint32(106).fork()).join();
    }
    if (message.runError !== undefined) {
      RunError.encode(message.runError, writer.uint32(114).fork()).join();
    }
    if (message.stepStarted !== undefined) {
      StepStarted.encode(message.stepStarted, writer.uint32(122).fork()).join();
    }
    if (message.stepFinished !== undefined) {
      StepFinished.encode(message.stepFinished, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.textMessageStart = TextMessageStart.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.textMessageContent = TextMessageContent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.textMessageEnd = TextMessageEnd.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toolCallStart = ToolCallStart.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolCallArgs = ToolCallArgs.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toolCallEnd = ToolCallEnd.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stateSnapshot = StateSnapshot.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stateDelta = StateDelta.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.messagesSnapshot = MessagesSnapshot.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rawEvent = RawEvent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.customEvent = CustomEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.runStarted = RunStarted.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.runFinished = RunFinished.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.runError = RunError.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.stepStarted = StepStarted.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.stepFinished = StepFinished.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.textMessageStart = (object.textMessageStart !== undefined && object.textMessageStart !== null)
      ? TextMessageStart.fromPartial(object.textMessageStart)
      : undefined;
    message.textMessageContent = (object.textMessageContent !== undefined && object.textMessageContent !== null)
      ? TextMessageContent.fromPartial(object.textMessageContent)
      : undefined;
    message.textMessageEnd = (object.textMessageEnd !== undefined && object.textMessageEnd !== null)
      ? TextMessageEnd.fromPartial(object.textMessageEnd)
      : undefined;
    message.toolCallStart = (object.toolCallStart !== undefined && object.toolCallStart !== null)
      ? ToolCallStart.fromPartial(object.toolCallStart)
      : undefined;
    message.toolCallArgs = (object.toolCallArgs !== undefined && object.toolCallArgs !== null)
      ? ToolCallArgs.fromPartial(object.toolCallArgs)
      : undefined;
    message.toolCallEnd = (object.toolCallEnd !== undefined && object.toolCallEnd !== null)
      ? ToolCallEnd.fromPartial(object.toolCallEnd)
      : undefined;
    message.stateSnapshot = (object.stateSnapshot !== undefined && object.stateSnapshot !== null)
      ? StateSnapshot.fromPartial(object.stateSnapshot)
      : undefined;
    message.stateDelta = (object.stateDelta !== undefined && object.stateDelta !== null)
      ? StateDelta.fromPartial(object.stateDelta)
      : undefined;
    message.messagesSnapshot = (object.messagesSnapshot !== undefined && object.messagesSnapshot !== null)
      ? MessagesSnapshot.fromPartial(object.messagesSnapshot)
      : undefined;
    message.rawEvent = (object.rawEvent !== undefined && object.rawEvent !== null)
      ? RawEvent.fromPartial(object.rawEvent)
      : undefined;
    message.customEvent = (object.customEvent !== undefined && object.customEvent !== null)
      ? CustomEvent.fromPartial(object.customEvent)
      : undefined;
    message.runStarted = (object.runStarted !== undefined && object.runStarted !== null)
      ? RunStarted.fromPartial(object.runStarted)
      : undefined;
    message.runFinished = (object.runFinished !== undefined && object.runFinished !== null)
      ? RunFinished.fromPartial(object.runFinished)
      : undefined;
    message.runError = (object.runError !== undefined && object.runError !== null)
      ? RunError.fromPartial(object.runError)
      : undefined;
    message.stepStarted = (object.stepStarted !== undefined && object.stepStarted !== null)
      ? StepStarted.fromPartial(object.stepStarted)
      : undefined;
    message.stepFinished = (object.stepFinished !== undefined && object.stepFinished !== null)
      ? StepFinished.fromPartial(object.stepFinished)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
