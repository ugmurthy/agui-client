// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Value } from "./google/protobuf/struct";
import { JsonPatchOperation } from "./patch";
import { Message } from "./types";

export const protobufPackage = "ag_ui";

export enum EventType {
  TEXT_MESSAGE_START = 0,
  TEXT_MESSAGE_CONTENT = 1,
  TEXT_MESSAGE_END = 2,
  TOOL_CALL_START = 3,
  TOOL_CALL_ARGS = 4,
  TOOL_CALL_END = 5,
  STATE_SNAPSHOT = 6,
  STATE_DELTA = 7,
  MESSAGES_SNAPSHOT = 8,
  RAW = 9,
  CUSTOM = 10,
  RUN_STARTED = 11,
  RUN_FINISHED = 12,
  RUN_ERROR = 13,
  STEP_STARTED = 14,
  STEP_FINISHED = 15,
  UNRECOGNIZED = -1,
}

export interface BaseEvent {
  type: EventType;
  timestamp?: number | undefined;
  rawEvent?: any | undefined;
}

export interface TextMessageStartEvent {
  baseEvent: BaseEvent | undefined;
  messageId: string;
  role?: string | undefined;
}

export interface TextMessageContentEvent {
  baseEvent: BaseEvent | undefined;
  messageId: string;
  delta: string;
}

export interface TextMessageEndEvent {
  baseEvent: BaseEvent | undefined;
  messageId: string;
}

export interface ToolCallStartEvent {
  baseEvent: BaseEvent | undefined;
  toolCallId: string;
  toolCallName: string;
  parentMessageId?: string | undefined;
}

export interface ToolCallArgsEvent {
  baseEvent: BaseEvent | undefined;
  toolCallId: string;
  delta: string;
}

export interface ToolCallEndEvent {
  baseEvent: BaseEvent | undefined;
  toolCallId: string;
}

export interface StateSnapshotEvent {
  baseEvent: BaseEvent | undefined;
  snapshot: any | undefined;
}

export interface StateDeltaEvent {
  baseEvent: BaseEvent | undefined;
  delta: JsonPatchOperation[];
}

export interface MessagesSnapshotEvent {
  baseEvent: BaseEvent | undefined;
  messages: Message[];
}

export interface RawEvent {
  baseEvent: BaseEvent | undefined;
  event: any | undefined;
  source?: string | undefined;
}

export interface CustomEvent {
  baseEvent: BaseEvent | undefined;
  name: string;
  value?: any | undefined;
}

export interface RunStartedEvent {
  baseEvent: BaseEvent | undefined;
  threadId: string;
  runId: string;
}

export interface RunFinishedEvent {
  baseEvent: BaseEvent | undefined;
  threadId: string;
  runId: string;
}

export interface RunErrorEvent {
  baseEvent: BaseEvent | undefined;
  code?: string | undefined;
  message: string;
}

export interface StepStartedEvent {
  baseEvent: BaseEvent | undefined;
  stepName: string;
}

export interface StepFinishedEvent {
  baseEvent: BaseEvent | undefined;
  stepName: string;
}

export interface Event {
  textMessageStart?: TextMessageStartEvent | undefined;
  textMessageContent?: TextMessageContentEvent | undefined;
  textMessageEnd?: TextMessageEndEvent | undefined;
  toolCallStart?: ToolCallStartEvent | undefined;
  toolCallArgs?: ToolCallArgsEvent | undefined;
  toolCallEnd?: ToolCallEndEvent | undefined;
  stateSnapshot?: StateSnapshotEvent | undefined;
  stateDelta?: StateDeltaEvent | undefined;
  messagesSnapshot?: MessagesSnapshotEvent | undefined;
  raw?: RawEvent | undefined;
  custom?: CustomEvent | undefined;
  runStarted?: RunStartedEvent | undefined;
  runFinished?: RunFinishedEvent | undefined;
  runError?: RunErrorEvent | undefined;
  stepStarted?: StepStartedEvent | undefined;
  stepFinished?: StepFinishedEvent | undefined;
}

function createBaseBaseEvent(): BaseEvent {
  return { type: 0, timestamp: undefined, rawEvent: undefined };
}

export const BaseEvent: MessageFns<BaseEvent> = {
  encode(message: BaseEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.timestamp !== undefined) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.rawEvent !== undefined) {
      Value.encode(Value.wrap(message.rawEvent), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawEvent = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BaseEvent>, I>>(base?: I): BaseEvent {
    return BaseEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaseEvent>, I>>(object: I): BaseEvent {
    const message = createBaseBaseEvent();
    message.type = object.type ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.rawEvent = object.rawEvent ?? undefined;
    return message;
  },
};

function createBaseTextMessageStartEvent(): TextMessageStartEvent {
  return { baseEvent: undefined, messageId: "", role: undefined };
}

export const TextMessageStartEvent: MessageFns<TextMessageStartEvent> = {
  encode(message: TextMessageStartEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.role !== undefined) {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageStartEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMessageStartEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TextMessageStartEvent>, I>>(base?: I): TextMessageStartEvent {
    return TextMessageStartEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextMessageStartEvent>, I>>(object: I): TextMessageStartEvent {
    const message = createBaseTextMessageStartEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messageId = object.messageId ?? "";
    message.role = object.role ?? undefined;
    return message;
  },
};

function createBaseTextMessageContentEvent(): TextMessageContentEvent {
  return { baseEvent: undefined, messageId: "", delta: "" };
}

export const TextMessageContentEvent: MessageFns<TextMessageContentEvent> = {
  encode(message: TextMessageContentEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.delta !== "") {
      writer.uint32(26).string(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageContentEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMessageContentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TextMessageContentEvent>, I>>(base?: I): TextMessageContentEvent {
    return TextMessageContentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextMessageContentEvent>, I>>(object: I): TextMessageContentEvent {
    const message = createBaseTextMessageContentEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messageId = object.messageId ?? "";
    message.delta = object.delta ?? "";
    return message;
  },
};

function createBaseTextMessageEndEvent(): TextMessageEndEvent {
  return { baseEvent: undefined, messageId: "" };
}

export const TextMessageEndEvent: MessageFns<TextMessageEndEvent> = {
  encode(message: TextMessageEndEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageEndEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMessageEndEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TextMessageEndEvent>, I>>(base?: I): TextMessageEndEvent {
    return TextMessageEndEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextMessageEndEvent>, I>>(object: I): TextMessageEndEvent {
    const message = createBaseTextMessageEndEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messageId = object.messageId ?? "";
    return message;
  },
};

function createBaseToolCallStartEvent(): ToolCallStartEvent {
  return { baseEvent: undefined, toolCallId: "", toolCallName: "", parentMessageId: undefined };
}

export const ToolCallStartEvent: MessageFns<ToolCallStartEvent> = {
  encode(message: ToolCallStartEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.toolCallName !== "") {
      writer.uint32(26).string(message.toolCallName);
    }
    if (message.parentMessageId !== undefined) {
      writer.uint32(34).string(message.parentMessageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallStartEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallStartEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolCallName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentMessageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToolCallStartEvent>, I>>(base?: I): ToolCallStartEvent {
    return ToolCallStartEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallStartEvent>, I>>(object: I): ToolCallStartEvent {
    const message = createBaseToolCallStartEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.toolCallId = object.toolCallId ?? "";
    message.toolCallName = object.toolCallName ?? "";
    message.parentMessageId = object.parentMessageId ?? undefined;
    return message;
  },
};

function createBaseToolCallArgsEvent(): ToolCallArgsEvent {
  return { baseEvent: undefined, toolCallId: "", delta: "" };
}

export const ToolCallArgsEvent: MessageFns<ToolCallArgsEvent> = {
  encode(message: ToolCallArgsEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.delta !== "") {
      writer.uint32(26).string(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallArgsEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallArgsEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToolCallArgsEvent>, I>>(base?: I): ToolCallArgsEvent {
    return ToolCallArgsEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallArgsEvent>, I>>(object: I): ToolCallArgsEvent {
    const message = createBaseToolCallArgsEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.toolCallId = object.toolCallId ?? "";
    message.delta = object.delta ?? "";
    return message;
  },
};

function createBaseToolCallEndEvent(): ToolCallEndEvent {
  return { baseEvent: undefined, toolCallId: "" };
}

export const ToolCallEndEvent: MessageFns<ToolCallEndEvent> = {
  encode(message: ToolCallEndEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallEndEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallEndEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToolCallEndEvent>, I>>(base?: I): ToolCallEndEvent {
    return ToolCallEndEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallEndEvent>, I>>(object: I): ToolCallEndEvent {
    const message = createBaseToolCallEndEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.toolCallId = object.toolCallId ?? "";
    return message;
  },
};

function createBaseStateSnapshotEvent(): StateSnapshotEvent {
  return { baseEvent: undefined, snapshot: undefined };
}

export const StateSnapshotEvent: MessageFns<StateSnapshotEvent> = {
  encode(message: StateSnapshotEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.snapshot !== undefined) {
      Value.encode(Value.wrap(message.snapshot), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateSnapshotEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateSnapshotEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snapshot = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StateSnapshotEvent>, I>>(base?: I): StateSnapshotEvent {
    return StateSnapshotEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateSnapshotEvent>, I>>(object: I): StateSnapshotEvent {
    const message = createBaseStateSnapshotEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.snapshot = object.snapshot ?? undefined;
    return message;
  },
};

function createBaseStateDeltaEvent(): StateDeltaEvent {
  return { baseEvent: undefined, delta: [] };
}

export const StateDeltaEvent: MessageFns<StateDeltaEvent> = {
  encode(message: StateDeltaEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    for (const v of message.delta) {
      JsonPatchOperation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateDeltaEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateDeltaEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delta.push(JsonPatchOperation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StateDeltaEvent>, I>>(base?: I): StateDeltaEvent {
    return StateDeltaEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateDeltaEvent>, I>>(object: I): StateDeltaEvent {
    const message = createBaseStateDeltaEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.delta = object.delta?.map((e) => JsonPatchOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessagesSnapshotEvent(): MessagesSnapshotEvent {
  return { baseEvent: undefined, messages: [] };
}

export const MessagesSnapshotEvent: MessageFns<MessagesSnapshotEvent> = {
  encode(message: MessagesSnapshotEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessagesSnapshotEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessagesSnapshotEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MessagesSnapshotEvent>, I>>(base?: I): MessagesSnapshotEvent {
    return MessagesSnapshotEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessagesSnapshotEvent>, I>>(object: I): MessagesSnapshotEvent {
    const message = createBaseMessagesSnapshotEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRawEvent(): RawEvent {
  return { baseEvent: undefined, event: undefined, source: undefined };
}

export const RawEvent: MessageFns<RawEvent> = {
  encode(message: RawEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.event !== undefined) {
      Value.encode(Value.wrap(message.event), writer.uint32(18).fork()).join();
    }
    if (message.source !== undefined) {
      writer.uint32(26).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RawEvent>, I>>(base?: I): RawEvent {
    return RawEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RawEvent>, I>>(object: I): RawEvent {
    const message = createBaseRawEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.event = object.event ?? undefined;
    message.source = object.source ?? undefined;
    return message;
  },
};

function createBaseCustomEvent(): CustomEvent {
  return { baseEvent: undefined, name: "", value: undefined };
}

export const CustomEvent: MessageFns<CustomEvent> = {
  encode(message: CustomEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CustomEvent>, I>>(base?: I): CustomEvent {
    return CustomEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomEvent>, I>>(object: I): CustomEvent {
    const message = createBaseCustomEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.name = object.name ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseRunStartedEvent(): RunStartedEvent {
  return { baseEvent: undefined, threadId: "", runId: "" };
}

export const RunStartedEvent: MessageFns<RunStartedEvent> = {
  encode(message: RunStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.threadId !== "") {
      writer.uint32(18).string(message.threadId);
    }
    if (message.runId !== "") {
      writer.uint32(26).string(message.runId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunStartedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunStartedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.threadId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RunStartedEvent>, I>>(base?: I): RunStartedEvent {
    return RunStartedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunStartedEvent>, I>>(object: I): RunStartedEvent {
    const message = createBaseRunStartedEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.threadId = object.threadId ?? "";
    message.runId = object.runId ?? "";
    return message;
  },
};

function createBaseRunFinishedEvent(): RunFinishedEvent {
  return { baseEvent: undefined, threadId: "", runId: "" };
}

export const RunFinishedEvent: MessageFns<RunFinishedEvent> = {
  encode(message: RunFinishedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.threadId !== "") {
      writer.uint32(18).string(message.threadId);
    }
    if (message.runId !== "") {
      writer.uint32(26).string(message.runId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFinishedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFinishedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.threadId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RunFinishedEvent>, I>>(base?: I): RunFinishedEvent {
    return RunFinishedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunFinishedEvent>, I>>(object: I): RunFinishedEvent {
    const message = createBaseRunFinishedEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.threadId = object.threadId ?? "";
    message.runId = object.runId ?? "";
    return message;
  },
};

function createBaseRunErrorEvent(): RunErrorEvent {
  return { baseEvent: undefined, code: undefined, message: "" };
}

export const RunErrorEvent: MessageFns<RunErrorEvent> = {
  encode(message: RunErrorEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.code !== undefined) {
      writer.uint32(18).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunErrorEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunErrorEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RunErrorEvent>, I>>(base?: I): RunErrorEvent {
    return RunErrorEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunErrorEvent>, I>>(object: I): RunErrorEvent {
    const message = createBaseRunErrorEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.code = object.code ?? undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseStepStartedEvent(): StepStartedEvent {
  return { baseEvent: undefined, stepName: "" };
}

export const StepStartedEvent: MessageFns<StepStartedEvent> = {
  encode(message: StepStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.stepName !== "") {
      writer.uint32(18).string(message.stepName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepStartedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepStartedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stepName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StepStartedEvent>, I>>(base?: I): StepStartedEvent {
    return StepStartedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepStartedEvent>, I>>(object: I): StepStartedEvent {
    const message = createBaseStepStartedEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.stepName = object.stepName ?? "";
    return message;
  },
};

function createBaseStepFinishedEvent(): StepFinishedEvent {
  return { baseEvent: undefined, stepName: "" };
}

export const StepFinishedEvent: MessageFns<StepFinishedEvent> = {
  encode(message: StepFinishedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEvent !== undefined) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.stepName !== "") {
      writer.uint32(18).string(message.stepName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepFinishedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepFinishedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stepName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StepFinishedEvent>, I>>(base?: I): StepFinishedEvent {
    return StepFinishedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepFinishedEvent>, I>>(object: I): StepFinishedEvent {
    const message = createBaseStepFinishedEvent();
    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)
      ? BaseEvent.fromPartial(object.baseEvent)
      : undefined;
    message.stepName = object.stepName ?? "";
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    textMessageStart: undefined,
    textMessageContent: undefined,
    textMessageEnd: undefined,
    toolCallStart: undefined,
    toolCallArgs: undefined,
    toolCallEnd: undefined,
    stateSnapshot: undefined,
    stateDelta: undefined,
    messagesSnapshot: undefined,
    raw: undefined,
    custom: undefined,
    runStarted: undefined,
    runFinished: undefined,
    runError: undefined,
    stepStarted: undefined,
    stepFinished: undefined,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textMessageStart !== undefined) {
      TextMessageStartEvent.encode(message.textMessageStart, writer.uint32(10).fork()).join();
    }
    if (message.textMessageContent !== undefined) {
      TextMessageContentEvent.encode(message.textMessageContent, writer.uint32(18).fork()).join();
    }
    if (message.textMessageEnd !== undefined) {
      TextMessageEndEvent.encode(message.textMessageEnd, writer.uint32(26).fork()).join();
    }
    if (message.toolCallStart !== undefined) {
      ToolCallStartEvent.encode(message.toolCallStart, writer.uint32(34).fork()).join();
    }
    if (message.toolCallArgs !== undefined) {
      ToolCallArgsEvent.encode(message.toolCallArgs, writer.uint32(42).fork()).join();
    }
    if (message.toolCallEnd !== undefined) {
      ToolCallEndEvent.encode(message.toolCallEnd, writer.uint32(50).fork()).join();
    }
    if (message.stateSnapshot !== undefined) {
      StateSnapshotEvent.encode(message.stateSnapshot, writer.uint32(58).fork()).join();
    }
    if (message.stateDelta !== undefined) {
      StateDeltaEvent.encode(message.stateDelta, writer.uint32(66).fork()).join();
    }
    if (message.messagesSnapshot !== undefined) {
      MessagesSnapshotEvent.encode(message.messagesSnapshot, writer.uint32(74).fork()).join();
    }
    if (message.raw !== undefined) {
      RawEvent.encode(message.raw, writer.uint32(82).fork()).join();
    }
    if (message.custom !== undefined) {
      CustomEvent.encode(message.custom, writer.uint32(90).fork()).join();
    }
    if (message.runStarted !== undefined) {
      RunStartedEvent.encode(message.runStarted, writer.uint32(98).fork()).join();
    }
    if (message.runFinished !== undefined) {
      RunFinishedEvent.encode(message.runFinished, writer.uint32(106).fork()).join();
    }
    if (message.runError !== undefined) {
      RunErrorEvent.encode(message.runError, writer.uint32(114).fork()).join();
    }
    if (message.stepStarted !== undefined) {
      StepStartedEvent.encode(message.stepStarted, writer.uint32(122).fork()).join();
    }
    if (message.stepFinished !== undefined) {
      StepFinishedEvent.encode(message.stepFinished, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.textMessageStart = TextMessageStartEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.textMessageContent = TextMessageContentEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.textMessageEnd = TextMessageEndEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toolCallStart = ToolCallStartEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolCallArgs = ToolCallArgsEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toolCallEnd = ToolCallEndEvent.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stateSnapshot = StateSnapshotEvent.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stateDelta = StateDeltaEvent.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.messagesSnapshot = MessagesSnapshotEvent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.raw = RawEvent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.custom = CustomEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.runStarted = RunStartedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.runFinished = RunFinishedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.runError = RunErrorEvent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.stepStarted = StepStartedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.stepFinished = StepFinishedEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.textMessageStart = (object.textMessageStart !== undefined && object.textMessageStart !== null)
      ? TextMessageStartEvent.fromPartial(object.textMessageStart)
      : undefined;
    message.textMessageContent = (object.textMessageContent !== undefined && object.textMessageContent !== null)
      ? TextMessageContentEvent.fromPartial(object.textMessageContent)
      : undefined;
    message.textMessageEnd = (object.textMessageEnd !== undefined && object.textMessageEnd !== null)
      ? TextMessageEndEvent.fromPartial(object.textMessageEnd)
      : undefined;
    message.toolCallStart = (object.toolCallStart !== undefined && object.toolCallStart !== null)
      ? ToolCallStartEvent.fromPartial(object.toolCallStart)
      : undefined;
    message.toolCallArgs = (object.toolCallArgs !== undefined && object.toolCallArgs !== null)
      ? ToolCallArgsEvent.fromPartial(object.toolCallArgs)
      : undefined;
    message.toolCallEnd = (object.toolCallEnd !== undefined && object.toolCallEnd !== null)
      ? ToolCallEndEvent.fromPartial(object.toolCallEnd)
      : undefined;
    message.stateSnapshot = (object.stateSnapshot !== undefined && object.stateSnapshot !== null)
      ? StateSnapshotEvent.fromPartial(object.stateSnapshot)
      : undefined;
    message.stateDelta = (object.stateDelta !== undefined && object.stateDelta !== null)
      ? StateDeltaEvent.fromPartial(object.stateDelta)
      : undefined;
    message.messagesSnapshot = (object.messagesSnapshot !== undefined && object.messagesSnapshot !== null)
      ? MessagesSnapshotEvent.fromPartial(object.messagesSnapshot)
      : undefined;
    message.raw = (object.raw !== undefined && object.raw !== null) ? RawEvent.fromPartial(object.raw) : undefined;
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? CustomEvent.fromPartial(object.custom)
      : undefined;
    message.runStarted = (object.runStarted !== undefined && object.runStarted !== null)
      ? RunStartedEvent.fromPartial(object.runStarted)
      : undefined;
    message.runFinished = (object.runFinished !== undefined && object.runFinished !== null)
      ? RunFinishedEvent.fromPartial(object.runFinished)
      : undefined;
    message.runError = (object.runError !== undefined && object.runError !== null)
      ? RunErrorEvent.fromPartial(object.runError)
      : undefined;
    message.stepStarted = (object.stepStarted !== undefined && object.stepStarted !== null)
      ? StepStartedEvent.fromPartial(object.stepStarted)
      : undefined;
    message.stepFinished = (object.stepFinished !== undefined && object.stepFinished !== null)
      ? StepFinishedEvent.fromPartial(object.stepFinished)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
